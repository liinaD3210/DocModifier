import streamlit as st
from docx import Document
from io import BytesIO
import os
import json
import html
import textwrap

try:
    from core.llm_handler import build_graph, GraphState
    from core.docx_modifier import extract_text_from_doc, modify_document_with_structured_instructions
    from core.docx_utils import find_paragraphs_with_text 
except ImportError as e:
    st.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {e}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—Å–µ —Ñ–∞–π–ª—ã 'core' –Ω–∞ –º–µ—Å—Ç–µ.")
    st.stop()

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã ---
st.set_page_config(
    page_title="–ê–≥–µ–Ω—Ç –ø—Ä–∞–≤–æ–∫ DOCX (LangGraph)",
    page_icon="üìÑ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ ---
@st.cache_resource
def get_graph():
    try:
        graph = build_graph()
        st.toast("‚úÖ –ì—Ä–∞—Ñ LangGraph —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return graph
    except Exception as e:
        st.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å LangGraph: {e}")
        return None

if 'app_graph' not in st.session_state:
    st.session_state.app_graph = get_graph()

def init_session_state(clear_all=False):
    if clear_all:
        graph = st.session_state.get('app_graph')
        for key in list(st.session_state.keys()):
            del st.session_state[key]
        st.session_state.app_graph = graph

    defaults = {
        "chat_messages": [], "current_doc_bytes": None, "original_file_name": None,
        "processing": False, "show_confirmation": False, 
        "proposed_instructions": None, "awaiting_clarification": False,
    }
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value

init_session_state()

# --- –§—É–Ω–∫—Ü–∏–∏-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ---

def get_diff_for_instruction(instruction: dict, doc: Document) -> dict:
    """
    –ì–æ—Ç–æ–≤–∏—Ç "–±—ã–ª–æ/—Å—Ç–∞–ª–æ" —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –∏–∑–º–µ–Ω—è–µ–º–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ –∏ —Ç—É—Å–∫–ª—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫–∏, –≥–æ—Ç–æ–≤—ã–µ –¥–ª—è st.markdown.
    """
    result = {'before': '–û—à–∏–±–∫–∞', 'after': '–û—à–∏–±–∫–∞', 'notes': '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø—Ä–∞–≤–∫—É.', 'found': False}
    
    if not doc:
        result['notes'] = '–û–±—ä–µ–∫—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞ –Ω–µ –±—ã–ª –ø–µ—Ä–µ–¥–∞–Ω.'
        return result

    try:
        op_type = instruction.get("operation_type")
        target = instruction.get("target_description", {})
        params = instruction.get("parameters", {})
        
        search_text = target.get("text_to_find")
        if not search_text:
            if op_type == "REPLACE_TEXT":
                search_text = params.get("old_text")
            elif op_type == "APPLY_FORMATTING":
                search_text = params.get("apply_to_text_segment")
        
        if not search_text:
            result['notes'] = 'LLM –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–ª–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–∏—Å–∫–∞.'
            return result

        all_paragraphs = list(doc.paragraphs)
        target_index = -1
        for i, p in enumerate(all_paragraphs):
            if search_text in p.text:
                target_index = i
                break
        
        if target_index == -1:
            result['notes'] = f'–¢–µ–∫—Å—Ç ¬´{html.escape(search_text)}¬ª –Ω–µ –±—ã–ª –Ω–∞–π–¥–µ–Ω.'
            return result
            
        context_window = 1
        start_idx = max(0, target_index - context_window)
        end_idx = min(len(all_paragraphs), target_index + context_window + 1)
        
        before_md_parts, after_md_parts = [], []
        notes = ""
        
        # CSS —Å—Ç–∏–ª—å –¥–ª—è —Ç—É—Å–∫–ª–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        context_style = "opacity: 0.6;"

        for i in range(start_idx, end_idx):
            p = all_paragraphs[i]
            is_target_p = (i == target_index)
            
            if is_target_p:
                text_before = p.text
                text_after, notes = "", ""
                
                # –ú–æ–¥–µ–ª–∏—Ä—É–µ–º "–ø–æ—Å–ª–µ" –∏ –∑–∞–º–µ—Ç–∫–∏
                if op_type == "REPLACE_TEXT":
                    old, new = params.get("old_text", ""), params.get("new_text", "")
                    text_after = text_before.replace(old, f"**{new}**") # –ò—Å–ø–æ–ª—å–∑—É–µ–º Markdown –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è
                    notes = f"–ó–∞–º–µ–Ω–∞ '{old}' –Ω–∞ '{new}'."
                elif op_type == "INSERT_TEXT":
                    to_insert = params.get("text_to_insert", "")
                    if params.get("position") == "after_paragraph":
                        text_after = text_before
                        notes = f"–ü–û–°–õ–ï —ç—Ç–æ–≥–æ –∞–±–∑–∞—Ü–∞ –±—É–¥–µ—Ç –≤—Å—Ç–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π: ¬´{to_insert}¬ª"
                    else:
                        text_after = text_before + f" **{to_insert}**"
                        notes = f"–í—Å—Ç–∞–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞: ¬´{to_insert}¬ª"
                elif op_type == "DELETE_ELEMENT":
                    text_after = f"~~{text_before}~~" # Markdown –¥–ª—è –∑–∞—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è
                    notes = "–ü–æ–ª–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –∞–±–∑–∞—Ü–∞."
                elif op_type == "APPLY_FORMATTING":
                    text_after = text_before
                    rules_str = [f"`{r.get('style')}`: `{r.get('value')}`" for r in params.get("formatting_rules", [])]
                    notes = f"–ë—É–¥–µ—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: {', '.join(rules_str)}"

                # –î–æ–±–∞–≤–ª—è–µ–º —Ü–µ–ª–µ–≤–æ–π –∞–±–∑–∞—Ü –±–µ–∑ —Ç—É—Å–∫–ª–æ–≥–æ —Å—Ç–∏–ª—è
                before_md_parts.append(text_before)
                after_md_parts.append(text_after)
                result['notes'] = notes
            else:
                # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ –∞–±–∑–∞—Ü—ã —Å —Ç—É—Å–∫–ª—ã–º —Å—Ç–∏–ª–µ–º
                context_text = html.escape(p.text)
                md_text = f"<span style='{context_style}'>{context_text}</span>"
                before_md_parts.append(md_text)
                after_md_parts.append(md_text)

        result['before'] = "<br><br>".join(before_md_parts)
        result['after'] = "<br><br>".join(after_md_parts)
        result['found'] = True
    except Exception as e:
        result['notes'] = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞: {e}"

    return result


def show_confirmation_ui(instructions: list[dict]):
    """
    –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç UI —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –∏–∑–º–µ–Ω—è–µ–º–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞ –∏ —Ç—É—Å–∫–ª—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
    """
    if "selected_instructions" not in st.session_state:
        st.session_state.selected_instructions = {i: True for i in range(len(instructions))}

    st.subheader("ü§ñ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø—Ä–∞–≤–∫–∏")
    st.caption("–°–Ω–∏–º–∏—Ç–µ –≥–∞–ª–æ—á–∫–∏ —Å –ø—Ä–∞–≤–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –Ω–µ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–º–µ–Ω—è—Ç—å.")
    st.markdown("---")
    
    doc_object = Document(BytesIO(st.session_state.current_doc_bytes))
    
    # –°—Ç–∏–ª—å –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —Å —Ä–∞–º–∫–æ–π
    container_style = "padding: 1rem; border: 1px solid #444; border-radius: 0.5rem;"

    for i, instruction in enumerate(instructions):
        with st.container(border=True):
            op_type = instruction.get("operation_type", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è")
            
            cols = st.columns([0.5, 9.5])
            with cols[0]:
                is_selected = st.checkbox(" ", value=st.session_state.selected_instructions.get(i, True), key=f"cb_{i}")
                st.session_state.selected_instructions[i] = is_selected
            with cols[1]:
                st.markdown(f"##### –ü—Ä–∞–≤–∫–∞ {i+1}: `{op_type}`")

            diff = get_diff_for_instruction(instruction, doc_object)
            
            # --- –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ "–ë—ã–ª–æ/–°—Ç–∞–ª–æ" —Å –ø–æ–º–æ—â—å—é st.markdown ---
            
            st.write("üî¥ **–ë—ã–ª–æ:**")
            st.markdown(f"<div style='{container_style}'>{diff['before']}</div>", unsafe_allow_html=True)
            
            st.write("üü¢ **–°—Ç–∞–Ω–µ—Ç:**")
            st.markdown(f"<div style='{container_style}'>{diff['after']}</div>", unsafe_allow_html=True)
            
            if diff['notes']:
                st.caption(f"‚ÑπÔ∏è –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: {diff['notes']}")
        
        st.markdown("<br>", unsafe_allow_html=True) 

    st.markdown("---")
    apply_col, cancel_col, _ = st.columns([2, 1, 3])
    if apply_col.button("‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –ø—Ä–∞–≤–∫–∏", use_container_width=True, type="primary"):
        handle_user_confirmation(approved=True)
    if cancel_col.button("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å –≤—Å–µ", use_container_width=True):
        handle_user_confirmation(approved=False)

def handle_user_prompt(user_input: str):
    st.session_state.processing = True
    st.session_state.chat_messages.append({"role": "user", "content": user_input})
    try:
        doc_content = extract_text_from_doc(Document(BytesIO(st.session_state.current_doc_bytes)))
        initial_state = GraphState(
            original_user_query=user_input, current_user_query=user_input,
            document_content_text=doc_content, document_bytes=st.session_state.current_doc_bytes,
            extracted_instructions=None, clarification_question=None, system_message=None, next_node_to_call=None
        )
        with st.spinner("ü§ñ –ê–≥–µ–Ω—Ç –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∞—à –∑–∞–ø—Ä–æ—Å..."):
            final_state = st.session_state.app_graph.invoke(initial_state, {"recursion_limit": 15})

        st.session_state.awaiting_clarification = bool(final_state.get("clarification_question"))
        if final_state.get("extracted_instructions"):
            st.session_state.proposed_instructions = final_state["extracted_instructions"]
            st.session_state.show_confirmation = True
        elif final_state.get("clarification_question"):
            st.session_state.chat_messages.append({"role": "assistant", "content": final_state["clarification_question"]})
        elif final_state.get("system_message"):
            st.session_state.chat_messages.append({"role": "assistant", "content": final_state["system_message"]})
        else:
             st.session_state.chat_messages.append({"role": "assistant", "content": "–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã—Ä–∞–±–æ—Ç–∞—Ç—å –ø–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å."})
    except Exception as e:
        st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∑–∞–ø—Ä–æ—Å–∞: {e}")
        st.session_state.chat_messages.append({"role": "assistant", "content": f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}"})
    finally:
        st.session_state.processing = False
        st.rerun()

def handle_user_confirmation(approved: bool):
    if not approved:
        st.session_state.chat_messages.append({"role": "assistant", "content": "–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –±—ã–ª–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω—ã."})
    else:
        selected_indices = [i for i, sel in st.session_state.selected_instructions.items() if sel]
        instructions_to_apply = [st.session_state.proposed_instructions[i] for i in selected_indices]
        if not instructions_to_apply:
            st.session_state.chat_messages.append({"role": "assistant", "content": "–í—ã –Ω–µ –≤—ã–±—Ä–∞–ª–∏ –Ω–∏ –æ–¥–Ω–æ–π –ø—Ä–∞–≤–∫–∏. –î–µ–π—Å—Ç–≤–∏—è –æ—Ç–º–µ–Ω–µ–Ω—ã."})
        else:
            st.session_state.processing = True
            st.session_state.chat_messages.append({"role": "assistant", "content": f"–ü—Ä–∏–º–µ–Ω—è—é {len(instructions_to_apply)} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π..."})
            try:
                doc = Document(BytesIO(st.session_state.current_doc_bytes))
                success = modify_document_with_structured_instructions(doc, instructions_to_apply)
                if success:
                    bio = BytesIO()
                    doc.save(bio)
                    st.session_state.current_doc_bytes = bio.getvalue()
                    st.session_state.chat_messages.append({"role": "assistant", "content": "–ò–∑–º–µ–Ω–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã."})
                else:
                    st.session_state.chat_messages.append({"role": "assistant", "content": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–ª–∏ –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è."})
            except Exception as e:
                st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π: {e}")
                st.session_state.chat_messages.append({"role": "assistant", "content": f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {e}"})
            finally:
                st.session_state.processing = False
    
    st.session_state.show_confirmation = False
    st.session_state.proposed_instructions = None
    if "selected_instructions" in st.session_state:
        del st.session_state.selected_instructions
    st.rerun()

# --- –û—Å–Ω–æ–≤–Ω–æ–π UI ---
st.title("üìÑ –ê–≥–µ–Ω—Ç –ø—Ä–∞–≤–æ–∫ DOCX (–Ω–∞ –±–∞–∑–µ LangGraph)")

with st.sidebar:
    st.header("–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞")
    uploaded_file = st.file_uploader("–í—ã–±–µ—Ä–∏—Ç–µ .docx —Ñ–∞–π–ª", type=["docx"], disabled=st.session_state.processing)
    
    if uploaded_file and uploaded_file.name != st.session_state.get("original_file_name"):
        init_session_state(clear_all=True)
        st.session_state.current_doc_bytes = uploaded_file.getvalue()
        st.session_state.original_file_name = uploaded_file.name
        st.success(f"–§–∞–π–ª '{uploaded_file.name}' –∑–∞–≥—Ä—É–∂–µ–Ω.")
        st.rerun()

    if st.session_state.original_file_name:
        st.info(f"–ê–∫—Ç–∏–≤–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç: **{st.session_state.original_file_name}**")
        if st.button("–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª", use_container_width=True, disabled=st.session_state.processing):
            init_session_state(clear_all=True)
            st.rerun()
        if st.session_state.current_doc_bytes:
            st.download_button("‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å —Ç–µ–∫—É—â–∏–π –¥–æ–∫—É–º–µ–Ω—Ç", st.session_state.current_doc_bytes,
                f"modified_{st.session_state.original_file_name}", "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                use_container_width=True, disabled=st.session_state.processing)

if not st.session_state.original_file_name:
    st.info("üëà –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ .docx –¥–æ–∫—É–º–µ–Ω—Ç –Ω–∞ –±–æ–∫–æ–≤–æ–π –ø–∞–Ω–µ–ª–∏, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.")
elif not st.session_state.app_graph:
    st.error("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ LangGraph. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
else:
    for msg in st.session_state.chat_messages:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])

    if st.session_state.show_confirmation and st.session_state.proposed_instructions:
        show_confirmation_ui(st.session_state.proposed_instructions)
    
    is_disabled = st.session_state.processing or st.session_state.show_confirmation
    prompt_text = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —É—Ç–æ—á–Ω—è—é—â–∏–π –≤–æ–ø—Ä–æ—Å:" if st.session_state.awaiting_clarification else "–ß—Ç–æ –±—ã –≤—ã —Ö–æ—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å?"
    
    if user_input := st.chat_input(prompt_text, disabled=is_disabled):
        handle_user_prompt(user_input)